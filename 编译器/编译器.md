---
title: 编译器
date: 2015-03-11 23:38:06
tags: 
---

[编译器](https://www.objccn.io/issue-6-2/)

#### 基础概念

##### 机器语言

> 机器语言是用[二进制](http://baike.baidu.com/view/18536.htm)代码表示的计算机能直接识别和执行的一种机器指令的集合
>
> - [CPU](https://zh.wikipedia.org/wiki/CPU)可直接解读的数据

```
以下是一些示例：
指令部份的示例
0000 代表 加载（LOAD）
0001 代表 存储（STORE）
...
暂存器部份的示例
0000 代表暂存器 A
0001 代表暂存器 B
...
存储器部份的示例
000000000000 代表地址为 0 的存储器
000000000001 代表地址为 1 的存储器
000000010000 代表地址为 16 的存储器
100000000000 代表地址为 2^11 的存储器
集成示例
0000,0000,000000010000 代表 LOAD A, 16
0000,0001,000000000001 代表 LOAD B, 1
0001,0001,000000010000 代表 STORE B, 16
0001,0001,000000000001 代表 STORE B, 1[1] 

```

#### 编译

编译[ 是从[源代码](http://baike.baidu.com/view/60376.htm)（通常为[高级语言](http://baike.baidu.com/view/14900.htm)）到能直接被计算机器或[虚拟机](http://baike.baidu.com/view/1132.htm)执行的[目标代码](http://baike.baidu.com/view/1272000.htm)（通常为低级语言或[机器语言](http://baike.baidu.com/view/111847.htm)）的翻译过程

#### 编译器前后端

*前端*:  前端是语言相关的，输出为抽象语法树；

>  clang 的功能是首先对 Objective-C 代码做分析检查，然后将其转换为低级的类汇编代码：

*后端:*后端是机器相关的，输出为机器代码。有些优化是机器无关的，这一部分可能被单列出来称为中端。

> LLVM Intermediate Representation(LLVM 中间表达码)。接着 LLVM 会执行相关指令将 LLVM IR 编译成目标平台上的本地字节码，这个过程的完成方式可以是即时编译 (Just-in-time)，或在编译的时候完成。



